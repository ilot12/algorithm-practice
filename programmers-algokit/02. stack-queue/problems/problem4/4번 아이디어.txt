              *
1 2 1 3 2 9 1 2 3 1 2 1
    *
9 1 2 3 1 2 1 1 2 1 3 2 
  *
1 2 3 1 2 1 1 2 1 3 2
                    *
3 1 2 1 1 2 1 3 2 1 2
                  *
1 2 1 1 2 1 3 2 1 2
      *
3 2 1 2 1 2 1 1 2 1


    *
2 1 2 1 2 1 1 2 1

2보다 큰 것들의 개수를 세면 3개임.
그래서 범위는 4 ~ 7임 (2가 4개기 때문)

그러면 2보다 큰 것들은 그냥 세고, 마지막으로 끝나는 3 혹은 4 혹은 ...을 구해야함.
내가 가진 2가 몇 번째인지 세는게 필요함.

max element를 돌 때 n번 순회를 하는 것보다 1 ~ 9 까지니까 9, 8, 7, ... 하는게 더 이득
n log n을 하고, 그거에 대해 수행하는 것보다 나은듯

그러면 9로 제일 손해보는 탐색을 하고(길이가 100이하이므로 100번이동), 8로 , 7로 ... 해서
마지막 내 target이 1이어도 해봤자 900번 탐색임.
그래서 정직하게 n^2탐색이어도 가능.

어차피 iterator의 count함수를 쓰면 n번 탐색하니까 target의 개수도 세면서 진행하자.

벡터를 실제로 바꾸면서 움직일지, 위치를 세면서 끝까지 가면 다시 처음으로 돌아가면서 셀지 고민.
벡터는 iterator로 뚝딱 옮기면 되니까 벡터를 바꾸면서 옮기는게 나을듯

        *
1 2 1 3 2 1 3 4 2 4 3 4 1 4 2

이걸 센다고 하면 
targetValue = 2 
targetPosition = 1(0부터라고 하자)
targetCount = 4 를 설정.

이제 9부터 쭉 탐색. 어차피 max_element를 사용한다고 해도 n번 탐색해야하기에 따로 하지 않아도 될듯.
9 쭉 진행. 없음. 5까지 같은 방식으로 진행. 없음.

4에 대해서 진행. 그러면 이 탐색에서 4의 마지막 위치를 세면서 가면서 2가 몇번 나오는지 셈.
새로운 벡터는 다음과 같이 진행하며 만듬.

4가 아닌 것들은 새로운 temp 벡터에 넣으면서 진행.
1,2,1,3,2,1,...은 넣고 4면 안넣고 answer를 1씩 증가.
근데 마지막 4 이후로는 temp에 안넣어야 함... 어떡하지??
먼저 세고 한번 더 도는건 하기 싫은데 ㅋㅋㅋ 근데 또 넣어놓고 자르는 것도 하기 싫음.
근데 하나도 없으면 이런 과정을 안거쳐도 됨. 그냥 안함.
그래서 먼저 세고 가는게 좋을듯.

이제 다시 생각해보자. 현재 반복문이 4를 세는거라면 4의 개수를 세면서 마지막 위치를 셈.
i에 대해 반복문을 돌테니 i = 4인 반복문
countI = 4
lastPositionI = 13
그럼 이제 새로운 다음 사이클을 위한 벡터는 13 + 1부터 end까지로 새로운 벡터 만들고
거기에 push_back으로 0 ~ 13 돌면서 4가 아닌 것들을 넣어서 만듬.
countI = 0이면 그 숫자에 대해 아무것도 수행하지 않으면 됨.

그러면 이제 이 cycle을 돌면서 답에 대해 어떻게 돌지 생각해보자.
마지막 4까지 가면서 2가 몇번 지나는지 세야한다.
답의 position은 현재 1이다.(2번째)
마지막 4까지 가면서 2는 3번 나온다.
새로 만든 vector에서 2의 위치는 2가 된다.(3번째)
이는 현재 position에서 지금까지 나온 2의 개수를 빼고, 이게 음수라면 targetCount를 더하면 된다.


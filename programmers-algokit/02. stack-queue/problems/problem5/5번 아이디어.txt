우선 답의 범위부터 보자.
최소보다 최대를 생각해보자.
최대는 다리 길이가 10000이고, 트럭은 10000대면서 모든 트럭이 다리 무게제한과 같다면
10000 * 10000이므로 int로 들어가진다.
하지만 계산하는 과정에서 int의 최대를 넘을 수 있으니 int로 하려면 계산 과정 중에는 한번 더 조심.

그러면 답이 최소 0부터 최대 100000000사이에 있음.
하지만 이분탐색으로는 진행하기 어려움.
중간에 n이 답인지 아닌지 판단하는게 어렵기 때문.
따라서 이분탐색 보다는 그냥 적절히 잘 돌아서 답을 찾아내는 게 좋음.

n이 1씩 증가하면서 큐에 넣고빼고 하는 건 시간 초과가 날 것 같음.
그래서 정직하게 1씩 증가하는 것이 아니라 무게가 변하는 시간을 큐에 넣어서
무게가 변하지 않는 동안은 탐색하지 않도록 하면 줄어들 것 같음.
예를 들어 길이가 10000이고 트럭무게 = 다리무게제한 이라면 10000이라는 시간동안은 무게가 변하지 않으니
따로 연산하지 않아도 되니 1씩 진행하면서 못올리니 +1 못올리니 +1 이걸 안해도 된다는 뜻.

변수
현재 다리 무게
트럭이 다리 마지막에 있는 시간 큐
현재 다리위에 있는 트럭 큐
현재 시간
대기 트럭 큐

트럭을 올려도 되는가? 함수
현재 다리 무게 = 1초 뒤의 다리 무게(현재 마지막 위치에 트럭이 있으면 빼라)
현재 다리 무게 + 다음 트럭 무게 <= 다리 무게 제한이면 참. 아니면 거짓.
참이면 다리에 트럭을 올리고, 1초뒤에 대해 반복문 수행해야함(메인에서 함)
거짓이면 다리에 트럭을 올리지 않고, 트럭이 다리 마지막에 있는 시간 큐.front에 대해 반복문 수행.(메인에서)

1초 뒤의 다리 무게 함수
현재 다리 무게 - 1초뒤에 트럭이 빠지는가? 함수
1초 뒤의 다리 무게 반환.

1초 뒤에 트럭이 빠지는가? 함수
큐가 비어있다면 0 반환.
트럭이 다리 마지막에 있는 시간 큐.front == 시간
같으면 빠지는 트럭무게 반환, 
트럭이 다리 마지막에 있는 시간 큐.pop_front, 
다리를 건너는 트럭 큐.pop_front
같지 않다면 0 반환.

트럭을 올려라 함수
트럭을 올려도 되는가? 가 참이면 수행
현재 다리 무게 += 대기 트럭 큐.front()
다리를 건너는 트럭 큐.push_back(대기 트럭에서 꺼냄)
대기 트럭 큐.pop_front()
트럭이 다리 마지막에 있는 시간 큐.push_back(현재 시간 + 다리 길이)

메인 반복문
현재 시간 0부터 시작.
반복문 나가는 조건은 대기 트럭 큐가 비어있으면.
트럭을 올려도 되는가?
참 => 트럭을 올려라, 다음 수행 시간 = 현재 시간 + 1
거짓 => 다음 수행 시간 = 트럭이 다리 마지막에 있는 시간 큐.front()

현재 다리 무게 = 0
현재 시간 = 0

현재 시간 0에 대해
트럭을 올려도 되는가? 수행
	1초뒤 다리 무게 함수 수행
		1초뒤 트럭이 빠지는가 수행 => 0 반환
	1초뒤 다리 무게 함수 => 0반환
트럭을 올려도 되는가 => 참 반환

참이므로 다음 수행: 현재시간+1인 1.

트럭을 올려라 함수 수행
	현재 다리 무게 = 7
	다리를 건너는 트럭 큐.push_back(7)
	대기 트럭 큐에서 7 빠짐
	트럭이 다리 마지막에 있는 시간 큐(2)
끝

현재 시간 1에 대해 반복문
트럭을 올려도 되는가? 수행
	1초뒤 다리 무게 함수 수행
		1초뒤 트럭이 빠지는가 수행
			큐가 비어있지 않으므로 다음 수행
			현재 시간 1 != 2 (트럭이 다리 마지막에 있는 시간 큐.front)
			같지 않으므로
		1초뒤 트럭이 빠지는가 0 반환
	1초뒤 다리 무게 함수 7 반환
	
	7 + 다음 트럭 무게 > 다리 무게 제한이므로
트럭을 올려도 되는가 거짓 반환

거짓이므로 다음 수행: 트럭이 다리 마지막에 있는 시간.front (2임)

현재 시간 2에 대해 반복문 수행
...

대기 트럭이 없을 때 까지 반복문 수행.
대기 트럭이 없다면, (트럭이 다리 마지막에 있는 시간.back()) + 1이 답입


